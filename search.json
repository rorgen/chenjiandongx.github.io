                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    [{"title":"Git 彻底删除大文件","date":"2019-09-18T16:07:43.350Z","url":"/2019/09/19/Git彻底删除大文件/","tags":["git"],"categories":["学习笔记"],"content":"pyecharts 的 git history 中存在着很多以前文档需要的图片，导致 pyecharts 整个 git 仓库体积达到 90M+，现在需要把这些图片彻底从 .git 中删除，整个过程会 overwrite 所有跟图片有关的 commit。"},{"title":"教你用 Python 从零开始写出简易版跳一跳外挂","date":"2019-09-17T16:17:11.839Z","url":"/2019/09/18/教你用Python从零开始写出简易版跳一跳外挂/","tags":["python"],"categories":["突发奇想"],"content":"关注 Python 的人想必都知道 跳一跳辅助外挂 这个项目近来在 Github 上火得不行，相信不少人也可能尝试过一番，并暗暗叹息，为什么我一开始就没有这个好想法呢！现在，参照外挂项目的源码，我们就从零开始来自己动手写一个手动版本的跳一跳外挂。思路：利用 adb 命令先把跳一跳截图保留至本地通过点击图上两个坐标点，算出两点之间的距离（勾股定理），最后得出按压屏幕的时间。通过 adb 命令执行按压屏幕操作重复 1 - 3 思路已经有了，就可以动手开码了。不过要先安装好 adb 环境，至于怎么配置安装，Google it！无非就是下载安装 adb 驱动，并设置好环境变量而已！先把后面需要的库引进来新建 WechatJump 类，并进行初始化操作首先需要保存图片至本地点击图片坐标点先点击 1 号点，再点击 2 好点即可按压屏幕，执行跳跃操作基本上函数已经完成了，最后整理一下，将 on_click 函数绑定到图片上，循环操作最后，只需要运行 run 函数即可，参数调得好的话，落点可以说是非常准了。手动刷到个上千分完全没问题，只要你要耐心…..怎么样，是不是觉得其实也不难写出来。（其实原作者的第一版大概就长这样子）不过现在该项目，已经推出了自动跳跃的版本，兼容 iphone 的版本，甚至有大牛直接上了深度学习的版本！（有兴趣的同学可以阅读一下其源码，相信会有收获的。）不过这都是后来的事啦，总之一句话，想法才是最重要的！附上本教程完整代码"},{"title":"常用 Git 命令整理","date":"2019-09-17T16:17:11.829Z","url":"/2019/09/18/常用Git命令整理/","tags":["git"],"categories":["学习笔记"],"content":"基本命令Git 配置 Github 账号"},{"title":"Python 中两个神奇的装饰器","date":"2019-09-17T16:17:11.806Z","url":"/2019/09/18/Python中两个神奇的装饰器/","tags":["python"],"categories":["学习笔记"],"content":"介绍一下 Python3 的两个装饰器 lru_cache 和 singledispatch，网上没什么的中文文章讲这个东西，最近刚好看书学习到的，就来跟大家分享分享详情请参看官方文档：(maxsize=128, typed=False)New in version 3.2.Changed in version 3.3: Added the typed option.  这个装饰器实现了备忘的功能，是一项优化技术，把耗时的函数的结果保存起来，避免传入相同的参数时重复计算。lru 是（least recently used）的缩写，即最近最少使用原则。表明缓存不会无限制增长，一段时间不用的缓存条目会被扔掉。这个装饰器支持传入参数，还能有这种操作的？maxsize 是保存最近多少个调用的结果，最好设置为 2 的倍数，默认为 128。如果设置为 None 的话就相当于是 maxsize 为正无穷了。还有一个参数是 type，如果 type 设置为 true，即把不同参数类型得到的结果分开保存，如 f(3) 和 f(3.0) 会被区分开。  写了个函数追踪结果递归函数适合使用这个装饰器，那就拿经典的斐波那契数列来测试吧  不使用缓存使用缓存测试代码，本电脑的 cpu 是 i5-5200Ufib(10) 调用了 177 次， 共花费了 0.007 秒  可以很明显的看到，使用缓存的时候，只调用了 11 次就得出了结果，并且花费时间只为 0.002 秒我们再把数字调大，传入的参数改为 31fib_with_cache(31)179 function calls (117 primitive calls) in 0.003 seconds   Ordered by: cumulative time   ncalls  tottime  percall  cumtime  percall filename:lineno(function)        1    0.000    0.000    0.003    0.003 {built-in method builtins.exec}        1    0.000    0.000    0.003    0.003 decorator.py:1()     32/1    0.000    0.000    0.003    0.003 decorator.py:5(inner)     32/1    0.000    0.000    0.003    0.003 decorator.py:18(fib_with_cache)       32    0.002    0.000    0.002    0.000 {built-in method builtins.print}       32    0.000    0.000    0.000    0.000 {method ‘format’ of ‘str’ objects}        2    0.000    0.000    0.000    0.000 decorator.py:4(track)        3    0.000    0.000    0.000    0.000 functools.py:43(update_wrapper)        1    0.000    0.000    0.000    0.000 functools.py:422(decorating_function)       21    0.000    0.000    0.000    0.000 {built-in method builtins.getattr}       15    0.000    0.000    0.000    0.000 {built-in method builtins.setattr}        2    0.000    0.000    0.000    0.000 functools.py:73(wraps)        3    0.000    0.000    0.000    0.000 {method ‘update’ of ‘dict’ objects}        1    0.000    0.000    0.000    0.000 functools.py:391(lru_cache)        1    0.000    0.000    0.000    0.000 {method ‘disable’ of ‘_lsprof.Profiler’ objects}@singledispatchNew in version 3.4.  使用过别的面向对象语言，如 java 等，肯定熟悉各种方法的重载，但是对于 Python 来说是不支持方法的重载的，不过其为我们提供了一个装饰器，能将普通函数变为泛函数（generic function）  比如你要针对不同类型的数据进行不同的处理，而又不想将它们写到一起，那就可以使用 @singledispatch 装饰器了  专门处理的函数无关紧要，所以使用 _ 来表示，当然你也可以写其他你喜欢的  测试  singledispatch 机制一个显著特征是，可以在系统的任何地方和任何模块中注册专门的函数，如果后来模块中增加了新的类型，可以轻松地添加一个新的专门函数来处理新类型。很像设计模式中的策略模式？"},{"title":"Python 中的魔法方法","date":"2019-09-17T16:17:11.787Z","url":"/2019/09/18/Python的并行和并发/","tags":["python"],"categories":["学习笔记"],"content":"Python 有很多的魔法方法，可以通过重写这些方法使类达到某个功能  二进制操作符增强型操作符一元操作符比较操作符"},{"title":"Python 中的并行与并发","date":"2019-09-17T16:17:11.773Z","url":"/2019/09/18/Python中的并行和并发/","tags":["python"],"categories":["学习笔记"],"content":"并发（concurrency）：在同一个处理器上快速的切换程序，只使用一个核心，指多线程并行（parallelism）：在多个处理器上同时运行多个程序，使用多个核心，指多进程  守护进程（daemon）：如果进程设置了 daemon=True 属性，主进程结束，子进程就随着结束了。用 subprocess 模块来管理子进程使用 multprocessing.Pool 模块启动多线程/进程使用 queue 模块启动线程队列Queue 是多进程安全的队列，可以使用 Queue 实现多进程之间的数据传递。  put 方法用以插入数据到队列中，put方法还有两个可选参数：blocked 和 timeout。如果 blocked 为 True（默认值），并且 timeout 为正值，该方法会阻塞 timeout 指定的时间，直到该队列有剩余的空间。如果超时，会抛出 Queue.Full 异常。如果 blocked 为 False，但该 Queue 已满，会立即抛出 Queue.Full 异常。  get 方法可以从队列读取并且删除一个元素。同样，get 方法有两个可选参数：blocked 和 timeout。如果 blocked 为 True（默认值），并且 timeout 为正值，那么在等待时间内没有取到任何元素，会抛出 Queue.Empty 异常。如果 blocked 为 False，有两种情况存在，如果 Queue 有一个值可用，则立即返回该值，否则，如果队列为空，则立即抛出 Queue.Empty 异常。使用 multiprocessing 创建多进程使用 Thread 创建多线程创建线程要执行的函数，把这个函数传递进 Thread 对象里，让它来执行继承 Thread 类，创建一个新的 class，将要执行的代码 写到 run 函数里面"},{"title":"Python 中的编码和解码","date":"2019-09-17T16:17:11.757Z","url":"/2019/09/18/Python中的编码和解码/","tags":["python"],"categories":["学习笔记"],"content":"把 Unicode 字符转换为二进制数据，使用 encode 方法；把二进制数据转换为 Unicode 字符，使用 decode 方法  python3 中的 str 为 unicode 类型，bytes 是包含原始的 8 位值，在 python3 中 str 和 bytes 不会等价，即使是空字符串也不行  函数接受 str 或 bytes，并总是返回 str 类型，解码（码：二进制）函数接受 str 或 bytes，并总是返回 bytes 类型，编码"},{"title":"B 站异步爬虫初体验","date":"2019-09-17T16:17:11.748Z","url":"/2019/09/18/B站异步爬虫初体验/","tags":["爬虫"],"categories":["突发奇想"],"content":"异步这个词在 JS 这样的编程语言中可以说是非常熟悉了，但是在 Python 中却一直是鲜为人知，毕竟 Python 可以支持多线程/多进程，并发/并行处理也可以提升效率。但是 Python3 中最雄心勃勃的库可以算是 asyncio 了。该库使得 Python 代码也可以写成异步的形式了！很赞是吧。异步代码编写也不算复杂，主要是比较难以理解。在看了多方文档之后，尝试来自己动手写一个异步爬虫试试，鉴于 B 站的 API 确实好爬，不容易被封，所以又被我拿来尝试了…..asyncio关于异步，这里先给出一个很经典的小栗子。相同的功能，普通的代码是这样的很明显，函数等待过程中线程并不会堵塞，而是先继续执行其他任务，等该任务执行完成再进行 回调。关于 asyncio 更多资料请阅读 官方文档。aiohttp用过 Python 的人肯定都用过 requests 库，但是该库是不支持异步的，看作者 Github 好像 3.0 版本开始会支持？在这里就要用到一个异步网络请求的第三库 aiohttp没听过的话先看看下面的例子，该库仅支持 Python3.5+，因为 3.5+ 才提供了 await/async 的语法不知道为什么，莫名觉得这样的代码写起来很舒服….接下来就是爬虫代码的编写了，参考了  这篇文章，具体请查看 async_bili.py。和我的另外一个 B 站多进程爬虫 chenjiandongx/bili-spider 做了速度的对比。多进程爬取 20000 条数据，并发 1024 个线程异步爬取 20000 条数据，并发数为 1000两者效率好像差了接近 4 倍….，可以初探到异步编程的魅力了！!"}]